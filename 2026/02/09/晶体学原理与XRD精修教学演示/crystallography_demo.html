<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Crystallography & XRD Refinement Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script>
    // ç¦ç”¨å³é”®èœå•
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        return false;
    });

    // ç¦ç”¨å¸¸è§å¿«æ·é”®
    document.addEventListener('keydown', function(e) {
        // F12
        if (e.key === 'F12') {
            e.preventDefault();
            return false;
        }
        // Ctrl+Shift+I (Chrome/Edge)
        if (e.ctrlKey && e.shiftKey && e.key === 'I') {
            e.preventDefault();
            return false;
        }
        // Ctrl+Shift+J (Chrome)
        if (e.ctrlKey && e.shiftKey && e.key === 'J') {
            e.preventDefault();
            return false;
        }
        // Ctrl+Shift+C (Chrome)
        if (e.ctrlKey && e.shiftKey && e.key === 'C') {
            e.preventDefault();
            return false;
        }
        // Ctrl+U (æŸ¥çœ‹æºä»£ç )
        if (e.ctrlKey && e.key === 'u') {
            e.preventDefault();
            return false;
        }
        // Ctrl+S (ä¿å­˜)
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            return false;
        }
    });
    </script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background-color: #f4f4f9; color: #333; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        #app { display: flex; flex-direction: column; height: 100vh; }
        
        /* å¯¼èˆªæ  */
        nav { background: #2c3e50; color: white; padding: 1rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 100; position: relative; }
        nav h1 { margin: 0; font-size: 1.2rem; display: flex; align-items: center; gap: 10px; }
        .nav-buttons button { background: transparent; border: 1px solid rgba(255,255,255,0.5); color: white; padding: 6px 12px; cursor: pointer; margin-left: 10px; border-radius: 4px; transition: all 0.3s; }
        .nav-buttons button:hover { background: rgba(255,255,255,0.1); }
        .nav-buttons button.active { background: #3498db; border-color: #3498db; font-weight: bold; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
        
        .main-content { flex: 1; position: relative; overflow: hidden; }
        .page-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; padding: 20px; gap: 20px; box-sizing: border-box; 
            background: #f4f4f9;
        }
        
        .panel-left { width: 320px; display: flex; flex-direction: column; gap: 15px; overflow-y: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); z-index: 2; }
        .panel-center { flex: 1; display: flex; flex-direction: column; gap: 15px; min-width: 0; }
        
        .control-group { border-bottom: 1px solid #eee; padding-bottom: 15px; }
        .control-group:last-child { border-bottom: none; }
        .control-group label { display: block; margin-bottom: 8px; font-weight: 600; font-size: 0.9rem; color: #2c3e50; }
        .control-group select, .control-group input[type=range] { width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ddd; }
        .value-display { font-family: 'Consolas', monospace; color: #e74c3c; float: right; font-weight: bold; }
        
        #canvas-container { flex: 1; background: #1a1a1a; border-radius: 8px; position: relative; min-height: 300px; box-shadow: inset 0 0 20px rgba(0,0,0,0.5); overflow: hidden; }
        
        /* å…¬å¼æ  */
        .formula-box { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); text-align: center; font-size: 1.2rem; position: relative; border-left: 5px solid #3498db; z-index: 50; }
        .interactive-formula span { cursor: help; border-bottom: 2px solid rgba(52, 152, 219, 0.3); padding: 0 2px; transition: background 0.2s; border-radius: 3px; position: relative; }
        .interactive-formula span:hover { background: #eaf2f8; color: #2980b9; border-bottom-color: #2980b9; }
        
        /* Tooltip å‘ä¸‹å¼¹å‡º */
        .interactive-formula span::after {
            content: attr(data-desc);
            position: absolute; top: 120%; left: 50%; transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.95); color: white; padding: 8px 12px; border-radius: 4px;
            font-size: 0.85rem; white-space: nowrap; opacity: 0; pointer-events: none; transition: all 0.2s; z-index: 2000; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .interactive-formula span::before {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: transparent transparent rgba(44, 62, 80, 0.95) transparent;
            opacity: 0; transition: opacity 0.2s; pointer-events: none; z-index: 2000;
        }
        .interactive-formula span:hover::after, .interactive-formula span:hover::before { opacity: 1; top: 110%; }

        /* ç»Ÿè®¡ä¸å›¾è¡¨ */
        .refine-stats { display: flex; justify-content: space-around; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .stat-item { text-align: center; }
        .stat-item small { color: #7f8c8d; text-transform: uppercase; font-size: 0.75rem; letter-spacing: 1px; }
        .stat-item strong { display: block; font-size: 1.8rem; color: #2c3e50; margin-top: 5px; }
        .good-fit { color: #27ae60 !important; } 
        .ok-fit { color: #f39c12 !important; }
        .bad-fit { color: #e74c3c !important; }
        
        button.action-btn { background: #27ae60; color: white; border: none; padding: 12px; width: 100%; cursor: pointer; border-radius: 6px; font-weight: bold; margin-top: 10px; transition: background 0.2s; font-size: 1rem; box-shadow: 0 2px 5px rgba(39, 174, 96, 0.3); }
        button.action-btn:hover { background: #219150; transform: translateY(-1px); }
        button.action-btn:disabled { background: #95a5a6; cursor: not-allowed; box-shadow: none; transform: none; }
        button.action-btn.secondary { background: #3498db; box-shadow: 0 2px 5px rgba(52, 152, 219, 0.3); }
        button.action-btn.secondary:hover { background: #2980b9; }

        #chart-container, #refine-chart-container { flex: 1; background: white; border-radius: 8px; padding: 10px; min-height: 300px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }

        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s ease; }
        .fade-enter, .fade-leave-to { opacity: 0; }
    </style>
</head>
<body>

<div id="app">
    <nav>
        <h1>âš›ï¸ {{ t('title') }} <span style="font-size: 0.75rem; color: rgba(255,255,255,0.5); font-weight: normal; margin-left: 10px;">@hellowei.cn</span></h1>
        <div class="nav-buttons">
            <button @click="switchMode('demo1')" :class="{active: mode==='demo1'}">{{ t('tab_sim') }}</button>
            <button @click="switchMode('demo2')" :class="{active: mode==='demo2'}">{{ t('tab_refine') }}</button>
            <span style="border-left:1px solid rgba(255,255,255,0.3); margin: 0 10px; height: 20px; display:inline-block; vertical-align:middle;"></span>
            <button @click="toggleLang" style="font-family: monospace;">{{ lang === 'zh' ? 'EN' : 'ä¸­' }}</button>
        </div>
    </nav>

    <div class="main-content">
        <transition name="fade">
        <div class="page-container" v-show="mode === 'demo1'">
            <div class="panel-left">
                <h3>ğŸ› ï¸ {{ t('params') }}</h3>
                <div class="control-group">
                    <label>{{ t('structure') }}</label>
                    <select v-model="d1.structure" @change="updateStructure">
                        <option value="sc">{{ t('sc') }}</option>
                        <option value="bcc">{{ t('bcc') }}</option>
                        <option value="fcc">{{ t('fcc') }}</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>{{ t('lattice_a') }} (Ã…) <span class="value-display">{{ d1.a }}</span></label>
                    <input type="range" v-model.number="d1.a" min="2.0" max="8.0" step="0.1" @input="updateStructure">
                </div>
                <div class="control-group">
                    <label>{{ t('wavelength') }} (Ã…) <span class="value-display">{{ d1.lambda }}</span></label>
                    <input type="range" v-model.number="d1.lambda" min="0.1" max="2.5" step="0.01" @input="updateXRD">
                </div>
                <div class="control-group">
                    <label>{{ t('peak_width') }} (FWHM)</label>
                    <input type="range" v-model.number="d1.fwhm" min="0.1" max="1.0" step="0.05" @input="updateXRD">
                </div>
                <div style="margin-top:auto; font-size:0.85rem; color:#7f8c8d; background:#f8f9fa; padding:10px; border-radius:4px; border-left:3px solid #f39c12;">
                    <strong>Hint:</strong> {{ t('d1_hint') }}
                </div>
            </div>

            <div class="panel-center">
                <div class="formula-box">
                    <div class="interactive-formula">
                        <strong>Bragg's Law: </strong>
                        <span :data-desc="t('desc_n')">n</span>
                        <span :data-desc="t('desc_lambda')">&lambda;</span>
                        = 2
                        <span :data-desc="t('desc_d')">d<sub>hkl</sub></span>
                        sin
                        <span :data-desc="t('desc_theta')">&theta;</span>
                    </div>
                </div>
                <div style="display:flex; gap:15px; flex:1; min-height:0;">
                    <div id="canvas-container"></div>
                    <div id="chart-container"></div>
                </div>
            </div>
        </div>
        </transition>

        <transition name="fade">
        <div class="page-container" v-show="mode === 'demo2'">
            <div class="panel-left">
                <h3>ğŸ“‰ {{ t('refine_panel') }}</h3>
                <div class="control-group">
                    <p style="font-size:0.9rem; line-height:1.5;">{{ t('step1_desc') }}</p>
                    <button class="action-btn" @click="importDataFromDemo1">
                        {{ t('import_data') }}
                    </button>
                    <div v-if="d2.hasData" style="margin-top:10px; padding:8px; background:#e8f8f5; color:#27ae60; border-radius:4px; font-size:0.85rem; display:flex; align-items:center;">
                        <span style="font-size:1.2rem; margin-right:5px;">âœ“</span> 
                        <div>{{ t('data_imported') }}<br><small>Target: {{ d1.structure.toUpperCase() }}, a={{ d1.a }}</small></div>
                    </div>
                </div>
                <div class="control-group" v-if="d2.hasData">
                    <label>{{ t('select_model') }}</label>
                    <select v-model="d2.selectedModel" @change="updateRefinement">
                        <option value="sc">{{ t('sc') }}</option>
                        <option value="bcc">{{ t('bcc') }}</option>
                        <option value="fcc">{{ t('fcc') }}</option>
                    </select>
                    <p style="font-size:0.8rem; color:#e74c3c; margin-top:5px;">âš ï¸ {{ t('model_hint') }}</p>
                </div>
                <div class="control-group" v-if="d2.hasData">
                    <label>{{ t('adjust_a') }} <span class="value-display">{{ d2.param_a.toFixed(4) }} Ã…</span></label>
                    <input type="range" v-model.number="d2.param_a" min="2.0" max="8.0" step="0.001" @input="updateRefinement">
                    <button class="action-btn secondary" @click="autoRefine" :disabled="isRefining">
                        {{ isRefining ? 'Refining...' : t('auto_refine') }}
                    </button>
                </div>
                <div class="control-group" v-if="d2.hasData">
                    <label>Optimization Algorithm</label>
                    <select v-model="d2.algo">
                        <option value="hill">{{ t('algo_hill') }}</option>
                        <option value="anneal">{{ t('algo_anneal') }}</option>
                        <option value="gradient">{{ t('algo_gradient') }}</option>
                    </select>
                </div>

                <div class="control-group" v-if="d2.hasData">
                    <label>{{ t('adjust_a') }} <span class="value-display">{{ d2.param_a.toFixed(4) }} Ã…</span></label>
                </div>
            </div>

            <div class="panel-center">
                <div class="formula-box" style="border-left-color: #e74c3c;">
                    <div class="interactive-formula">
                        <strong>Stats: </strong>
                        <span :data-desc="t('desc_rwp')">R<sub>wp</sub></span>,
                        <span :data-desc="t('desc_rp')">R<sub>p</sub></span>,
                        <span :data-desc="t('desc_chi2')">&chi;<sup>2</sup></span>
                    </div>
                </div>
                <div class="refine-stats">
                    <div class="stat-item">
                        <small>R<sub>wp</sub> (%)</small>
                        <strong :class="getFitClass(d2.rwp)">
                            {{ d2.hasData ? d2.rwp : '--' }}
                        </strong>
                    </div>
                    <div class="stat-item">
                        <small>R<sub>p</sub> (%)</small>
                        <strong :class="getFitClass(d2.rp)">
                            {{ d2.hasData ? d2.rp : '--' }}
                        </strong>
                    </div>
                    <div class="stat-item">
                        <small>Chi<sup>2</sup></small>
                        <strong :class="getChi2Class(d2.chi2)">
                            {{ d2.hasData ? d2.chi2 : '--' }}
                        </strong>
                    </div>
                </div>
                <div id="refine-chart-container"></div>
            </div>
        </div>
        </transition>
    </div>
</div>

<script>
    new Vue({
        el: '#app',
        data: {
            mode: 'demo1',
            lang: 'zh',
            isRefining: false,
            
            texts: {
                zh: {
                    title: 'æ™¶ä½“å­¦åŸç†ä¸XRDç²¾ä¿®æ•™å­¦',
                    tab_sim: '1. ç»“æ„ä¸XRDæ¨¡æ‹Ÿ',
                    tab_refine: '2. XRDç²¾ä¿®åŸç†',
                    params: 'å‚æ•°æ§åˆ¶',
                    structure: 'æ™¶ä½“ç»“æ„',
                    sc: 'ç®€å•ç«‹æ–¹ (SC)',
                    bcc: 'ä½“å¿ƒç«‹æ–¹ (BCC)',
                    fcc: 'é¢å¿ƒç«‹æ–¹ (FCC)',
                    lattice_a: 'æ™¶èƒå‚æ•° a',
                    wavelength: 'Xå°„çº¿æ³¢é•¿ Î»',
                    peak_width: 'å³°å®½ (FWHM)',
                    d1_hint: 'æ‚¬åœåœ¨çº¢è‰²çš„è¡å°„å³°ä¸Šï¼Œå¯æŸ¥çœ‹å¯¹åº”çš„æ™¶é¢æŒ‡æ•°(hkl)ã€‚',
                    desc_n: 'è¡å°„çº§æ•° (æ•´æ•°)',
                    desc_lambda: 'Xå°„çº¿æ³¢é•¿ (åŸƒ)',
                    desc_d: 'æ™¶é¢é—´è· (ä¸æ™¶èƒå‚æ•°æœ‰å…³)',
                    desc_theta: 'è¡å°„è§’ (å¸ƒæ‹‰æ ¼è§’)',
                    desc_rwp: 'åŠ æƒå›¾è°±æ®‹å·® (æƒé‡è€ƒè™‘äº†è®¡æ•°ç»Ÿè®¡)',
                    desc_rp: 'å›¾è°±æ®‹å·® (ç»å¯¹è¯¯å·®ä¹‹å’Œ/è§‚æµ‹å€¼ä¹‹å’Œ)',
                    desc_chi2: 'æ‹Ÿåˆä¼˜åº¦ (Goodness of Fit)ï¼Œç†æƒ³å€¼æ¥è¿‘1',
                    desc_w: 'æƒé‡å› å­ (é€šå¸¸ä¸º 1/Yobs)',
                    desc_yobs: 'è§‚æµ‹å¼ºåº¦ (å®éªŒæ•°æ®)',
                    desc_ycalc: 'è®¡ç®—å¼ºåº¦ (ç†è®ºæ¨¡å‹)',
                    refine_panel: 'ç²¾ä¿®æ§åˆ¶å°',
                    step1_desc: 'ç¬¬ä¸€æ­¥ï¼šç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ï¼Œå°† Tab 1 ä¸­æ¨¡æ‹Ÿçš„å›¾è°±å¯¼å…¥ä½œä¸ºâ€œå®éªŒè§‚æµ‹æ•°æ®â€ã€‚',
                    import_data: 'â¬‡ï¸ å¯¼å…¥æ¨¡æ‹Ÿæ•°æ®',
                    data_imported: 'æ•°æ®å·²åŠ è½½',
                    select_model: 'é€‰æ‹©æ‹Ÿåˆæ¨¡å‹',
                    model_hint: 'å¦‚æœç»“æ„æ¨¡å‹é€‰é”™ï¼Œå³°ä½æ°¸è¿œæ— æ³•å¯¹é½ï¼ŒRwp æ— æ³•ä¸‹é™ã€‚',
                    adjust_a: 'ç²¾ä¿®æ™¶èƒå‚æ•°',
                    auto_refine: 'âœ¨ è‡ªåŠ¨æ‹Ÿåˆ (çœŸå®ç®—æ³•)',
                    algo_hill: 'å˜æ­¥é•¿çˆ¬å±±æ³• (Hill Climbing)',
                    algo_anneal: 'æ¨¡æ‹Ÿé€€ç« (Simulated Annealing)',
                    algo_gradient: 'æ¢¯åº¦ä¸‹é™ (Gradient Descent)',
                },
                en: {
                    title: 'Crystallography & Refinement Demo',
                    tab_sim: '1. Structure & Sim',
                    tab_refine: '2. Refinement Logic',
                    params: 'Parameters',
                    structure: 'Crystal Structure',
                    sc: 'Simple Cubic (SC)',
                    bcc: 'Body Centered (BCC)',
                    fcc: 'Face Centered (FCC)',
                    lattice_a: 'Lattice Param a',
                    wavelength: 'Wavelength Î»',
                    peak_width: 'Peak Width',
                    d1_hint: 'Hover over the red peaks to see the Miller Indices (hkl).',
                    desc_n: 'Diffraction Order',
                    desc_lambda: 'X-ray Wavelength',
                    desc_d: 'Interplanar Spacing',
                    desc_theta: 'Diffraction Angle',
                    desc_rwp: 'Weighted Profile Residual',
                    desc_rp: 'Profile Residual (Unweighted)',
                    desc_chi2: 'Goodness of Fit (Ideal is ~1.0)',
                    desc_w: 'Weighting Factor',
                    desc_yobs: 'Observed Intensity',
                    desc_ycalc: 'Calculated Intensity',
                    refine_panel: 'Refinement Console',
                    step1_desc: 'Step 1: Import simulated pattern from Tab 1 as "Observed Data".',
                    import_data: 'â¬‡ï¸ Import Data',
                    data_imported: 'Data Loaded',
                    select_model: 'Select Model',
                    model_hint: 'Wrong space group implies peaks will never match.',
                    adjust_a: 'Refine Parameter',
                    auto_refine: 'âœ¨ Auto Fit (Real Algo)',
                    algo_hill: 'Hill Climbing (Variable Step)',
                    algo_anneal: 'Simulated Annealing',
                    algo_gradient: 'Gradient Descent',
                }
            },

            d1: { structure: 'sc', a: 4.0, lambda: 1.54, fwhm: 0.3 },
            // æ–°å¢ rp å’Œ chi2 å˜é‡
            d2: { hasData: false, obsData: {x:[], y:[], noiseOnly:[]}, selectedModel: 'sc', param_a: 3.5, rwp: 0, rp: 0, chi2: 0, algo: 'hill' },
            three: { scene: null, camera: null, renderer: null, atoms: [], lines: null, animationId: null }
        },
        watch: {
            mode(newVal) {
                this.$nextTick(() => {
                    if (newVal === 'demo1') Plotly.Plots.resize('chart-container');
                    else {
                        if(!this.d2.hasData) this.drawEmptyRefineChart();
                        Plotly.Plots.resize('refine-chart-container');
                    }
                });
            }
        },
        methods: {
            t(key) { return this.texts[this.lang][key]; },
            toggleLang() { 
                this.lang = this.lang === 'zh' ? 'en' : 'zh'; 
                this.updateXRD(); 
                if(this.d2.hasData) this.updateRefinement();
                else if(this.mode === 'demo2') this.drawEmptyRefineChart();
            },
            switchMode(m) { this.mode = m; },
            
            // é€šç”¨çš„æ ·å¼åˆ¤å®š
            getFitClass(val) {
                if (!this.d2.hasData) return '';
                const r = parseFloat(val);
                if (r < 5.0) return 'good-fit'; 
                if (r < 15) return 'ok-fit';
                return 'bad-fit';
            },
            // Chi2 çš„æ ·å¼åˆ¤å®šå•ç‹¬å†™ï¼Œå› ä¸ºæ ‡å‡†ä¸åŒ
            getChi2Class(val) {
                if (!this.d2.hasData) return '';
                const r = parseFloat(val);
                if (r >= 0.8 && r <= 1.5) return 'good-fit';
                if (r < 5) return 'ok-fit';
                return 'bad-fit';
            },

            // --- Three.js setup ---
            initThree() {
                const container = document.getElementById('canvas-container');
                if(!container) return;
                this.three.scene = new THREE.Scene();
                this.three.scene.background = new THREE.Color(0x1a1a1a);
                this.three.camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 100);
                this.three.camera.position.set(3.5, 3.5, 4.5);
                this.three.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.three.renderer.setSize(container.offsetWidth, container.offsetHeight);
                container.appendChild(this.three.renderer.domElement);
                const controls = new THREE.OrbitControls(this.three.camera, this.three.renderer.domElement);
                controls.enableDamping = true;
                this.three.scene.add(new THREE.AmbientLight(0x404040, 1.5));
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 5, 5);
                this.three.scene.add(dirLight);
                window.addEventListener('resize', () => {
                    if(this.mode === 'demo1') {
                        this.three.camera.aspect = container.offsetWidth / container.offsetHeight;
                        this.three.camera.updateProjectionMatrix();
                        this.three.renderer.setSize(container.offsetWidth, container.offsetHeight);
                        Plotly.Plots.resize('chart-container');
                    } else {
                        Plotly.Plots.resize('refine-chart-container');
                    }
                });
                this.animate();
                this.updateStructure();
            },
            animate() {
                this.three.animationId = requestAnimationFrame(this.animate);
                this.three.renderer.render(this.three.scene, this.three.camera);
            },
            updateStructure() {
                const scene = this.three.scene;
                this.three.atoms.forEach(a => scene.remove(a));
                this.three.atoms = [];
                if(this.three.lines) scene.remove(this.three.lines);
                const type = this.d1.structure;
                const visualSize = 2.0; 
                const atomGeo = new THREE.SphereGeometry(0.25, 32, 32);
                const atomMat = new THREE.MeshPhongMaterial({ color: 0x3498db, shininess: 80 });
                const addAtom = (x, y, z) => {
                    const mesh = new THREE.Mesh(atomGeo, atomMat);
                    mesh.position.set((x-0.5)*visualSize, (y-0.5)*visualSize, (z-0.5)*visualSize);
                    scene.add(mesh);
                    this.three.atoms.push(mesh);
                };
                for(let x=0; x<=1; x++) for(let y=0; y<=1; y++) for(let z=0; z<=1; z++) addAtom(x, y, z);
                if (type === 'bcc') addAtom(0.5, 0.5, 0.5);
                else if (type === 'fcc') [[0.5,0.5,0], [0.5,0.5,1], [0.5,0,0.5], [0.5,1,0.5], [0,0.5,0.5], [1,0.5,0.5]].forEach(p => addAtom(...p));
                const boxGeo = new THREE.BoxGeometry(visualSize, visualSize, visualSize);
                const edges = new THREE.EdgesGeometry(boxGeo);
                this.three.lines = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xbdc3c7 }));
                scene.add(this.three.lines);
                this.updateXRD();
            },

            // --- XRD ç‰©ç†æ ¸å¿ƒè®¡ç®— (å« hkl æ˜ å°„) ---
            calculatePattern(a, structure, lambda, fwhm, addNoise = false) {
                const hklList = []; 
                const uniquePeaksMap = new Map();
                const maxIndex = 4;
                
                for(let h=0; h<=maxIndex; h++) {
                    for(let k=0; k<=maxIndex; k++) {
                        for(let l=0; l<=maxIndex; l++) {
                            if(h==0 && k==0 && l==0) continue;
                            let allowed = false;
                            const sum = h+k+l;
                            if (structure === 'sc') allowed = true;
                            else if (structure === 'bcc') allowed = (sum % 2 === 0);
                            else if (structure === 'fcc') {
                                const par = [h%2, k%2, l%2];
                                allowed = (par.every(p => p===0) || par.every(p => p!==0));
                            }
                            if (allowed) {
                                const d = a / Math.sqrt(h*h + k*k + l*l);
                                const sinTheta = lambda / (2*d);
                                if (sinTheta <= 0.98) {
                                    const thetaRad = Math.asin(sinTheta);
                                    const twoTheta = 2 * thetaRad * (180/Math.PI);
                                    let multiplicity = 6;
                                    const distinct = new Set([h,k,l]).size;
                                    if(distinct===1) multiplicity = 8; 
                                    else if(distinct===3) multiplicity = 48; 
                                    else multiplicity = 24; 
                                    
                                    const lp = (1 + Math.pow(Math.cos(2*thetaRad), 2)) / (Math.pow(Math.sin(thetaRad), 2) * Math.cos(thetaRad));
                                    const intensity = multiplicity * lp * 10; 

                                    if(twoTheta > 0.1 && twoTheta < 110) {
                                        hklList.push({ twoTheta, intensity });

                                        const key = Math.round(twoTheta * 100);
                                        if(!uniquePeaksMap.has(key)) {
                                            uniquePeaksMap.set(key, {
                                                twoTheta: twoTheta,
                                                intensity: intensity, 
                                                label: `(${h}${k}${l})`
                                            });
                                        } else {
                                            const existing = uniquePeaksMap.get(key);
                                            existing.intensity += intensity;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // ç”Ÿæˆæ›²çº¿
                const x = [];
                const y = [];
                const step = 0.05;
                
                // æé«˜èƒŒæ™¯
                const background = 1000; 

                for(let i=0; i<=100; i+=step) {
                    x.push(i);
                    let sumI = 0;
                    hklList.forEach(peak => {
                        const val = peak.intensity * Math.exp( -2.77 * Math.pow(i - peak.twoTheta, 2) / Math.pow(fwhm, 2) );
                        sumI += val;
                    });
                    
                    sumI += background;

                    if (addNoise) {
                        // 1. åŸºåº•éšæœºéœ‡è¡
                        const baseNoise = (Math.random() - 0.5) * 15;
                        // 2. ä¿¡å·æ³Šæ¾å™ªå£°
                        const poissonNoise = (Math.random() - 0.5) * 2.0 * Math.sqrt(sumI);
                        sumI += baseNoise + poissonNoise;
                    }
                    
                    y.push(sumI);
                }

                // å¤„ç† Tooltip æ•°æ®
                const peakMarkers = { x: [], y: [], text: [] };
                uniquePeaksMap.forEach(p => {
                    peakMarkers.x.push(p.twoTheta);
                    peakMarkers.y.push(p.intensity * 1.05 + background); 
                    peakMarkers.text.push(`hkl: ${p.label}<br>2Î¸: ${p.twoTheta.toFixed(2)}Â°`);
                });

                return { x, y, peakMarkers };
            },

            updateXRD() {
                const data = this.calculatePattern(this.d1.a, this.d1.structure, this.d1.lambda, this.d1.fwhm, true);
                
                const traceLine = {
                    x: data.x, y: data.y, mode: 'lines',
                    line: { color: '#e74c3c', width: 1.5 },
                    name: 'Intensity',
                    hoverinfo: 'none'
                };

                const traceMarkers = {
                    x: data.peakMarkers.x,
                    y: data.peakMarkers.y,
                    mode: 'markers',
                    marker: { size: 10, color: 'rgba(0,0,0,0)' },
                    text: data.peakMarkers.text,
                    hoverinfo: 'text',
                    showlegend: false
                };

                const layout = {
                    title: this.lang === 'zh' ? 'æ¨¡æ‹Ÿ XRD å›¾è°± (å« hkl æç¤º)' : 'Simulated Pattern (with hkl)',
                    xaxis: { title: '2Theta (deg)' },
                    yaxis: { title: 'Intensity (Counts)' },
                    margin: { t: 40, r: 20, b: 50, l: 60 },
                    showlegend: false,
                    hovermode: 'closest'
                };
                Plotly.newPlot('chart-container', [traceLine, traceMarkers], layout, {responsive: true, displayModeBar: false});
            },

            // --- Demo 2 é€»è¾‘ ---
            drawEmptyRefineChart() {
                const layout = {
                    title: this.lang === 'zh' ? 'ç­‰å¾…æ•°æ®...' : 'Waiting for data...',
                    xaxis: { title: '2Theta (deg)', range: [0, 100] },
                    yaxis: { showticklabels: false, range: [0, 100] },
                    margin: { t: 40, r: 20, b: 40, l: 40 },
                    annotations: [{
                        text: this.lang === 'zh' ? 'è¯·å…ˆå¯¼å…¥æ•°æ®' : 'Please Import Data',
                        xref: 'paper', yref: 'paper', x: 0.5, y: 0.5, showarrow: false,
                        font: { size: 20, color: '#95a5a6' }
                    }]
                };
                Plotly.newPlot('refine-chart-container', [], layout, {responsive: true, displayModeBar: false});
            },

            importDataFromDemo1() {
                const data = this.calculatePattern(this.d1.a, this.d1.structure, this.d1.lambda, this.d1.fwhm, true);
                this.d2.obsData = { x: data.x, y: data.y };
                this.d2.hasData = true;
                this.d2.param_a = this.d1.a + 0.3; 
                this.d2.selectedModel = this.d1.structure; 
                this.updateRefinement();
            },

            updateRefinement() {
                if (!this.d2.hasData) return;

                // è®¡ç®—ç†è®ºæ¨¡å‹ (æ— éšæœºå™ªå£°)
                const calc = this.calculatePattern(this.d2.param_a, this.d2.selectedModel, this.d1.lambda, this.d1.fwhm, false);
                
                const yObs = this.d2.obsData.y;
                const yCalc = calc.y;
                const diff = [];
                
                let sNum = 0, sDen = 0; // for Rwp
                let sAbsDiff = 0, sSumObs = 0; // for Rp

                for(let i=0; i<yObs.length; i++) {
                    const d = yObs[i] - yCalc[i];
                    diff.push(d - 2000); 

                    // æƒé‡ w = 1/Yobs
                    const w = 1 / (yObs[i] > 10 ? yObs[i] : 10);
                    
                    // Rwp
                    sNum += w * (d * d);
                    sDen += w * (yObs[i] * yObs[i]);
                    
                    // Rp
                    sAbsDiff += Math.abs(d);
                    sSumObs += yObs[i];
                }
                
                this.d2.rwp = (Math.sqrt(sNum/sDen) * 100).toFixed(2);
                this.d2.rp = ((sAbsDiff / sSumObs) * 100).toFixed(2);
                const dof = yObs.length;
                this.d2.chi2 = (sNum / dof).toFixed(2);

                const traceObs = { 
                    x: this.d2.obsData.x, y: yObs, 
                    mode: 'markers', marker: {size: 2, color:'black'}, 
                    name: 'Y_obs', hoverinfo: 'none'
                };
                const traceCalc = { 
                    x: calc.x, y: yCalc, 
                    mode: 'lines', line: {color:'#e74c3c', width: 1.5}, 
                    name: 'Y_calc', hoverinfo: 'none'
                };
                
                const traceCalcMarkers = {
                    x: calc.peakMarkers.x, y: calc.peakMarkers.y,
                    mode: 'markers', marker: { size: 10, color: 'rgba(0,0,0,0)' },
                    text: calc.peakMarkers.text, hoverinfo: 'text', showlegend: false
                };

                const traceDiff = { 
                    x: calc.x, y: diff, 
                    mode: 'lines', line: {color:'#3498db', width: 1}, 
                    name: 'Diff', hoverinfo: 'none'
                };

                const layout = {
                    title: 'Rietveld Plot',
                    xaxis: { title: '2Theta' },
                    yaxis: { title: 'Intensity' },
                    margin: { t: 40, r: 10, b: 50, l: 60 },
                    legend: { x: 0.8, y: 1 },
                    hovermode: 'closest',
                    shapes: [{ type: 'line', x0: 10, x1: 90, y0: -2000, y1: -2000, line: {color:'gray', dash:'dash', width:1} }]
                };

                Plotly.react('refine-chart-container', [traceObs, traceCalc, traceDiff, traceCalcMarkers], layout);
            },

            // --- è¿™æ˜¯ä¸€ä¸ªçœŸæ­£çš„æ‹Ÿåˆç®—æ³• ---
            async autoRefine() {
                if(!this.d2.hasData) return;
                this.isRefining = true;
                //this.d2.selectedModel = this.d1.structure; // å¼ºåˆ¶ä¿®æ­£æ¨¡å‹

                if (this.d2.algo === 'hill') {
                    await this.runHillClimbing();
                } else if (this.d2.algo === 'anneal') {
                    await this.runSimulatedAnnealing();
                } else if (this.d2.algo === 'gradient') {
                    await this.runGradientDescent();
                }

                this.isRefining = false;
            },

            // ç®—æ³• 1: å˜æ­¥é•¿çˆ¬å±±æ³• (èªæ˜ã€å¿«é€Ÿ)
            async runHillClimbing() {
                let step = 0.05;
                const minStep = 0.0001;
                const maxIter = 100;

                this.updateRefinement();
                let bestRwp = parseFloat(this.d2.rwp);

                for (let i = 0; i < maxIter; i++) {
                    const centerA = this.d2.param_a;
                    
                    // è¯•æ¢å·¦å³
                    this.d2.param_a = centerA + step; this.updateRefinement();
                    const rightRwp = parseFloat(this.d2.rwp);
                    
                    this.d2.param_a = centerA - step; this.updateRefinement();
                    const leftRwp = parseFloat(this.d2.rwp);

                    // å†³ç­–
                    if (rightRwp < bestRwp && rightRwp < leftRwp) {
                        this.d2.param_a = centerA + step;
                        bestRwp = rightRwp;
                        step *= 1.2; // åŠ é€Ÿ
                    } else if (leftRwp < bestRwp && leftRwp < rightRwp) {
                        this.d2.param_a = centerA - step;
                        bestRwp = leftRwp;
                        step *= 1.2; // åŠ é€Ÿ
                    } else {
                        this.d2.param_a = centerA;
                        step *= 0.6; // å‡é€Ÿ
                    }

                    this.updateRefinement();
                    if (step < minStep) break;
                    await new Promise(r => setTimeout(r, 30));
                }
            },

            // ç®—æ³• 2: æ¨¡æ‹Ÿé€€ç« (æœ‰è¶£ï¼šå‰æœŸä¼šä¹±è·³ï¼Œèƒ½è·³å‡ºå±€éƒ¨æœ€ä¼˜)
            async runSimulatedAnnealing() {
                let temp = 10.0; // åˆå§‹æ¸©åº¦
                const coolingRate = 0.90; // é™æ¸©ç³»æ•°
                const maxIter = 150;
                
                this.updateRefinement();
                let currentRwp = parseFloat(this.d2.rwp);
                let bestA = this.d2.param_a;
                let bestRwp = currentRwp;

                for (let i = 0; i < maxIter; i++) {
                    // éšæœºæ‰°åŠ¨ï¼šæ¸©åº¦è¶Šé«˜ï¼Œè·³å¾—è¶Šè¿œ
                    const range = 0.5 * (temp / 10.0); 
                    const nextA = this.d2.param_a + (Math.random() - 0.5) * range;
                    
                    // æš‚æ—¶åº”ç”¨æ–°å‚æ•°è®¡ç®— Rwp
                    const oldA = this.d2.param_a;
                    this.d2.param_a = nextA;
                    this.updateRefinement();
                    const nextRwp = parseFloat(this.d2.rwp);

                    // è®¡ç®—èƒ½é‡å·® (Delta E)
                    const delta = nextRwp - currentRwp;

                    // æ¥å—å‡†åˆ™ï¼š
                    // 1. å¦‚æœæ–°ç»“æœæ›´å¥½ (delta < 0)ï¼Œç›´æ¥æ¥å—
                    // 2. å¦‚æœæ–°ç»“æœæ›´å·® (delta > 0)ï¼Œä»¥æ¦‚ç‡ P = exp(-delta / T) æ¥å—
                    if (delta < 0 || Math.random() < Math.exp(-delta / temp)) {
                        currentRwp = nextRwp;
                        if (currentRwp < bestRwp) {
                            bestRwp = currentRwp;
                            bestA = nextA;
                        }
                    } else {
                        // æ‹’ç»ï¼Œé€€å›ä¸Šä¸€æ­¥
                        this.d2.param_a = oldA;
                        this.updateRefinement();
                    }

                    // é™æ¸©
                    temp *= coolingRate;

                    // å¦‚æœæ¸©åº¦æä½ï¼Œç›´æ¥è·³åˆ°å†å²æœ€ä¼˜è§£å¹¶ç»“æŸ
                    if (temp < 0.01) {
                        this.d2.param_a = bestA;
                        this.updateRefinement();
                        break;
                    }

                    await new Promise(r => setTimeout(r, 30));
                }
            },

            // ä¼˜åŒ–åçš„ç®—æ³• 3: æ¢¯åº¦ä¸‹é™ (å¸¦å›æº¯å’Œè‡ªé€‚åº”å­¦ä¹ ç‡)
            // æ”¹è¿›ç‚¹ï¼šå¢åŠ â€œåæ‚”æœºåˆ¶â€ï¼Œå¦‚æœä¸€æ­¥èµ°åäº†å°±æ’¤é”€å¹¶å‡é€Ÿï¼Œä¿è¯ä¸€å®šèƒ½æ”¶æ•›åˆ°æå°å€¼
            async runGradientDescent() {
                let learningRate = 0.01; // åˆå§‹å­¦ä¹ ç‡
                const delta = 0.005;     // ç”¨äºè®¡ç®—å¯¼æ•°çš„å¾®å°åç§»
                const maxIter = 200;     // æœ€å¤§è¿­ä»£æ¬¡æ•°
                const minGrad = 0.01;    // æ¢¯åº¦é˜ˆå€¼

                // è·å–åˆå§‹è¯¯å·®
                this.updateRefinement();
                let currentRwp = parseFloat(this.d2.rwp);

                for(let i=0; i<maxIter; i++) {
                    const currentA = this.d2.param_a;
                    
                    // 1. ã€æ”¹è¿›ã€‘ä½¿ç”¨ä¸­å¿ƒå·®åˆ†æ³•è®¡ç®—æ¢¯åº¦ (Central Difference)
                    // ç²¾åº¦æ¯”å‰å‘å·®åˆ†æ›´é«˜ï¼š f'(x) â‰ˆ (f(x+h) - f(x-h)) / 2h
                    
                    // è®¡ç®— x + h
                    this.d2.param_a = currentA + delta;
                    this.updateRefinement();
                    const yPlus = parseFloat(this.d2.rwp);

                    // è®¡ç®— x - h
                    this.d2.param_a = currentA - delta;
                    this.updateRefinement();
                    const yMinus = parseFloat(this.d2.rwp);

                    // æ¢å¤å½“å‰ä½ç½®
                    this.d2.param_a = currentA;

                    // è®¡ç®—æ¢¯åº¦
                    const gradient = (yPlus - yMinus) / (2 * delta);

                    // 2. è®¡ç®—è¿™ä¸€æ­¥æƒ³èµ°çš„è·ç¦»
                    let step = learningRate * gradient;

                    // ã€æ”¹è¿›ã€‘æ¢¯åº¦è£å‰ª (Gradient Clipping)
                    // é™åˆ¶ä¸€æ­¥æœ€å¤§åªèƒ½èµ° 0.1Aï¼Œé˜²æ­¢æ¢¯åº¦çˆ†ç‚¸å¯¼è‡´å‚æ•°é£å‡ºå±å¹•
                    if (step > 0.1) step = 0.1;
                    if (step < -0.1) step = -0.1;

                    // 3. è¯•æ¢æ€§ç§»åŠ¨
                    const proposedA = currentA - step;

                    // 4. ã€å…³é”®æ”¹è¿›ã€‘éªŒè¯æœºåˆ¶ (Backtracking)
                    // å…ˆçœ‹çœ‹è¿™ä¸€æ­¥èµ°è¿‡å»ï¼Œè¯¯å·®æ˜¯ä¸æ˜¯çœŸçš„å˜å°äº†ï¼Ÿ
                    this.d2.param_a = proposedA;
                    this.updateRefinement(); // è¿™ä¸€æ­¥ä¼šæ›´æ–° d2.rwp
                    const newRwp = parseFloat(this.d2.rwp);

                    if (newRwp >= currentRwp) {
                        // ç³Ÿç³•ï¼è¯¯å·®åè€Œå˜å¤§ï¼ˆæˆ–è€…æ²¡å˜ï¼‰ï¼Œè¯´æ˜æ­¥å­è¿ˆå¤§äº†ï¼Œæˆ–è€…æ–¹å‘ä¸å¯¹
                        // ç­–ç•¥ï¼šæ’¤é”€ç§»åŠ¨ï¼Œå¤§å¹…é™ä½å­¦ä¹ ç‡ (å‡é€Ÿ)
                        this.d2.param_a = currentA; // å›é€€
                        learningRate *= 0.5; 
                        this.updateRefinement(); // æ¢å¤ UI æ˜¾ç¤º
                        
                        // å¦‚æœå­¦ä¹ ç‡å·²ç»éå¸¸å°ï¼Œè¯´æ˜èµ°ä¸åŠ¨äº†ï¼Œç»“æŸ
                        if(learningRate < 0.00001) break;
                    } else {
                        // å¾ˆå¥½ï¼è¯¯å·®å˜å°äº†
                        // ç­–ç•¥ï¼šç¡®è®¤ç§»åŠ¨ï¼Œå¹¶å°è¯•å¾®é‡åŠ é€Ÿ (Bold Driver)
                        currentRwp = newRwp;
                        // ç¨å¾®å¢åŠ ä¸€ç‚¹å­¦ä¹ ç‡ï¼Œé¼“åŠ±åœ¨å¹³å¦åŒºåŸŸèµ°å¿«ç‚¹
                        learningRate *= 1.05; 
                    }

                    // åœæ­¢æ¡ä»¶ï¼šæ¢¯åº¦æå¹³
                    if (Math.abs(gradient) < minGrad) {
                        console.log("Gradient converged");
                        break;
                    }

                    await new Promise(r => setTimeout(r, 30));
                }
            }
        },
        mounted() {
            this.initThree();
            this.updateXRD();
        }
    });
</script>
</body>
</html>